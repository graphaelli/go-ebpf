// bin_data.go
// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT

// Copyright 2017 Elasticsearch Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package exec

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"io"
)

var assets map[string][]byte

func asset(key string) ([]byte, error) {
	if assets == nil {
		assets = map[string][]byte{}

		var value []byte
		value, _ = base64.StdEncoding.DecodeString("H4sIAAAAAAAC/6yUMWzTThTGPzvJP/k3EYqEhELpkAXUKckGEkuWAkOHqgNiC645lIokTW1T0oIEC1IHBhYkRpAYMjB0S7YwMjJmzMCQkY1MMbq7z8Sx47YDT3J+ft+7d+/u3Tmvt7bvmYaBwAz8xsJbWC29eK/ztwADo2taewvgCoBRVvsDTvJyfeZr/iKn5IQckz/I7+Q3ckiekX3yE/mRfE+ekm/IHtklm+Rj8hG5Qz4g6+QdskZukmWyRBbJHAlyNuf+yek86FdG+mtj5Y8Odb9eGEAZgL0+Ubp98lPHP+t41gCmc98fmECR80ge201Ex804Th6oHCePcGTpeMlcPt9BSi9Ijrsh667pcxt94XxpYDz3/XPzJTPAJutdlz7jH8h06EF6eY4spVkqHru/s4257/vF4J6e7CL3Km8U5Fr4/L2rJi5lKaRiWkX1MxvTbyo9F9MLSs/E9C2lx+cvKf2/mD40gu8PKjoL+bIVG1j4KlTxRM9D2+q6VXEkOp6r313Psp81PMeyhYvGkXDc/YMOGq19W3RcgYojWhXRbDx1rLZA1znYE43uoegJW4WeK6UaKK7neNYeKu5xW/Jf2BPV97gNKXoR3VjhBz0KWz2hXuQa4eEF+dG7Ez3xXQD/r6hzyvWX6ee5zyC/GLrjxooedFl344L1X03If3fJ/GpCft9cPT7a/1sJ+V8T8qP+XeZHP9EzCjWc3//bCf3vp5b7nOe4aP9bK2pLm1Dsh/ZthvKD/5c/AAAA//8BAAD//2Y8/kswBwAA")
		value, _ = gzipDecode(value)
		assets["exec.o"] = value
	}

	if value, found := assets[key]; found {
		return value, nil
	}
	return nil, fmt.Errorf("asset not found for key=%v", key)
}

func gzipDecode(data []byte) ([]byte, error) {
	gz, err := gzip.NewReader(bytes.NewReader(data))
	if err != nil {
		return nil, err
	}

	out := new(bytes.Buffer)
	if _, err = io.Copy(out, gz); err != nil {
		return nil, err
	}

	return out.Bytes(), nil
}
